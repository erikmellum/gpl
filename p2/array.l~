/*
  Use this file as a starting point for your scanner.

  Use the following global variable to retrieve the current symbol (the one
  just read):

    char *yytext

  Use the following global variable to send information back to main():
      
    extern YYSTYPE yylval;

  The union YYSTYPE is the union declared in array.y.
  It is defined in y.tab.h (which is included by parser.h).
  You can use a union just like a struct (which is a lot like a class),
  except that only one member variable can be used at a time.
  y.tab.h is generated by bison from array.y.

*/

/* the %{ indicates the start of C/C++ code section */
/* you can put whatever C/C++ code in here that you want */
/* this code is copied to the generated file */
%{

#include "error.h"    // gpl file, using now to get use to it
#include "parser.h"   // gpl file, using now to get use to ti

// #include <ctype.h>
#include <iostream>
using namespace std;

Error error_handler; // error reporting object

// The following variable keeps track of what input line flex is reading.
// It will be used (by other parts of the program) for reporting the line
// numbers of errors.
// 
// It will be used by other parts of the program via the extern construct
//   If another .cpp file declares "extern int line_count" that line_count
//   in that file will be the line_count in this file (it becomes global)
int line_count = 1;

int emit_int(int token)
{
  // convert the string yytext into an integer
  // put it into the global union used to send values to the parser (.y file)
  // the union and its union_int field are declared in the .y file
  yylval.union_int = atoi(yytext);

  return token;
}

int emit_string(int token)
{
  // Would like to put a string in the union, but the way the union works
  // it has to be a pointer to a string
  // This is a potential memory leak.  Think carefully about where and when
  // this memory should be deleted.
  yylval.union_string = new string(yytext);

  return token;
}

int emit_double(int token)
{
  // Would like to put a double in the union, but the way the union works
  // it has to be a pointer to a string
  // This is a potential memory leak.  Think carefully about where and when
  // this memory should be deleted.
  yylval.union_double = atof(yytext);

  return token;
}

int emit_error(int token)
{
  // have the error handling object report the problem
  // note: it uses line_count as a global variable
  error_handler.error(Error::ILLEGAL_TOKEN, yytext);

  // create a string to hold the current text
  // put that string in the yylval union so it can be used by parser (.y file)
  yylval.union_string = new string(yytext);
  return token;
}

// the %} below indicates the end of the C/C++ code section

%}

/*
The %% below indicates the start of the rules flex/lex will use
The left-hand-side (LHS) give a regular expression
The right-hand-side (RHS) gives an action (code to execute)
*/

%%

[\n]            line_count++; // count the lines for error reporting
[ \t\r]         ; // ignore spaces, tabs and the microsoft line feed (\r)

","             return T_COMMA;
"="             return T_ASSIGN;
"{"             return T_LBRACE;
"}"             return T_RBRACE;
";"             return T_SEMIC;

[0-9]+          return emit_int(T_INT_CONSTANT);

[a-z]+\[\]      return emit_string(T_ID);

[a-zA-z]*|[a-zA-Z]+|[a-zA-z]*       return emit_string(T_ID);

([\.][0-9]+)|([0-9]+[\.][0-9]*) return emit_double(T_DOUBLE_CONSTANT);

.                return emit_error(T_ERROR);
